---
title: 'Final Project'
author: "Kelsey Gonzalez and Laura Werthmann"
date: "Due Dec 11, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE,fig.width=5)
```


Load packages
```{r}
library(tidyverse)    # data manipulation and visualization
library(kernlab)      # SVM methodology
library(e1071)        # SVM methodology
library(ISLR)         # contains example data set "Khan"
library(RColorBrewer) # customized coloring of plots
library(performanceEstimation) # for performance estimation of svm
library(RCurl) # for performance estimation of svm
library(factoextra) #for hopkins statistic
library(clustertend) #for hopkins statistic
library(cluster) # for gower similarity, pam, and diana (a divisive hierarchical method). clara() is also included, which is basically pam by sampling
library(Rtsne) # for t-SNE plot


```

#Data Preprocessing

Review of World Health Organization's Life Expectancy Data taken from [Kaggle](https://www.kaggle.com/kumarajarshi/life-expectancy-who).

```{r}
rm(list=ls())
load("LifeExpectancyData.Rdata")
data$Status = as.factor(data$Status)
data = subset(data,select = -c(`Hepatitis B`))
```

Then we aquire data to include continent values and make our cuboid navigation easier. This will allow us to "roll up" to other country-key table elements.
```{r}
# from https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes
ISO3166 <- read.csv(text = (getURL("https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv")))
ISO3166$name <- as.character(ISO3166$name)
# They use Eswatini instead of Swaziland, so let's update that & other naming mismatches
ISO3166$name[ISO3166$name == "Moldova, Republic of"] <- "Republic of Moldova"
ISO3166$name[ISO3166$name == "Korea, Republic of"] <- "Republic of Korea"
ISO3166$name[ISO3166$name == "Korea (Democratic People's Republic of)"] <- "Democratic People's Republic of Korea"
ISO3166$name[ISO3166$name == "Congo, Democratic Republic of the"] <- "Democratic Republic of the Congo"
ISO3166$name[ISO3166$name == "North Macedonia"] <- "The former Yugoslav republic of Macedonia"
ISO3166$name[ISO3166$name == "Tanzania, United Republic of"] <- "United Republic of Tanzania"
```

We created a country data frame to make the data join more easily, and then joined them by country("country", "name"), while adding the continent ("region")
```{r}
countries <- as.data.frame(unique(data$Country))
colnames(countries) <- "Country" 
countries$Country <- as.character(countries$Country)

dfcountry <- left_join(x = countries, 
                   y = ISO3166, 
                   by = c("Country" = "name"))


data <- left_join(x = data,
                   y = dfcountry[,c("Country","region")], 
                   by = c("Country" = "Country"))
```

Cluster pre-processing??
```{r}
data$Life <- data$`Life expectancy`
data$Status = as.factor(data$Status)
data$Country = as.factor(data$Country)

data <- data %>% select(-c(Polio, "percentage expenditure", Measles, `HIV/AIDS`)) 

data2013 <- data %>% filter(Year=="2013") %>% drop_na()

```



```{r, echo=FALSE}
#http://rpubs.com/nicholas_dirienzo/523778
require(reshape2)

data_melted <- data %>%
  filter(Year == 2013) %>% 
  drop_na() %>% 
  select(-Year, -Country, -Status, -region) %>% 
  scale() #make all the variables on the same scale

summary(data_melted)

data_melted <- melt(as.data.frame(data_melted))

ggplot(data_melted,
       aes(x = value)) +
  geom_histogram() +
  scale_x_continuous(name="Distribution", limits=c(-2, 2)) +
  facet_wrap(~variable)

```



#Descriptive Analyses
## Pam Clustering 


First things first, do our data even have a natural clustering tendency?
the smaller the result, the higher clustering tendency
```{r}
#Hopkins, for numerical data only 
# Compute Hopkins statistic for iris dataset:n must be no larger than num of samples
# seed set internally in the function, always give the same result.

data_no_cat <- data2013 %>% select(-Country, -Status, -region, -Year) %>% as.matrix()
rownames(data_no_cat) <- data2013$Country

res <- get_clust_tendency(data_no_cat, n=137, graph = TRUE)
res$hopkins_stat
res$plot

set.seed(1)
res <- hopkins(data_no_cat, n = 137)
res$H #very small, < 0.5, good clustering tendency
```





```{r}
gower_dist <- daisy(data2013[, -1],
                    metric = "gower",
                    type = list(logratio = "GDP", 
                                logratio = "Population"))

# Check attributes to ensure the correct methods are being used (I = interval, N = nominal)
# Note that despite logratio being called, the type remains coded as "I"

# cleaning it up
gower_mat <- as.matrix(gower_dist)
rownames(gower_mat) <- colnames(gower_mat) <- data2013$Country


```

Calculate Silhouette width for 2 to 10 clusters using PAM

```{r}
sil <- c(NA)
for(i in 2:10){
  pam_fit <- pam(gower_mat, diss=TRUE, k=i)
  sil[i] <-pam_fit$silinfo$avg.width
}

plot(1:10, sil,
xlab = "Number of clusters",
ylab = "Silhouette Width",
lines(1:10, sil))
```

```{r}
pam_fit <- pam(gower_dist, diss = TRUE, k = 2)
# add cluster labels to the data. We will use result1 later
data_clean <- data.frame(data2013, pam_fit$cluster)
# show clustering results by country
result1 <- data_clean %>% select(Country,pam_fit.cluster)
clusplot(pam_fit)

```

group_by cluster and then compute the summary data (means, median, etc) for each cluster
```{r}
data_results <- data_clean %>%
  mutate(cluster = pam_fit.cluster) %>% #add the cluster column
  select(-pam_fit.cluster) %>% 
  group_by(cluster) %>% #group countries by its cluster 
  do(the_summary = summary(.)) #do: summarize by group/cluster,add the_summary column

data_results$the_summary
```
The results suggest

_REWRITE_

One way to visualize many variables in a lower dimensional space is with t-distributed stochastic neighborhood embedding, or t-SNE. 
```{r}
tsne_obj <- Rtsne(gower_dist, is_distance = TRUE)

tsne_data_pam <- tsne_obj$Y %>%
  data.frame() %>% 
  setNames(c("X", "Y")) %>%
  mutate(cluster = factor(pam_fit$clustering),
         name = data_clean$Country)

ggplot(aes(x = X, y = Y), data = tsne_data_pam) +
  geom_point(aes(color = cluster)) + 
  geom_text(data=subset(tsne_data_pam[pam_fit$medoids, ]), # add names of centroids in
            aes(X,Y,label=name))
```
clearly pam isn't the ideal clustering algorithm here. 

## Hierarchical Clustering 

```{r}
h <- hclust(d = as.dist(gower_dist), method="complete")
plot(h, cex = 0.6, hang = -1, main="Hierarchal Cluster of Predicted Probabilities")
abline(h=quantile(gower_dist, .90))
```

```{r}
tsne_data_hc <- tsne_obj$Y %>%
  data.frame() %>% 
  setNames(c("X", "Y")) %>%
  mutate(cluster = factor(cutree(h, h=quantile(gower_dist, .90))),
         name = data_clean$Country)

set.seed(5)
labels <- tsne_data_hc %>%
    group_by(cluster) %>%
    sample_n(.,1) 

tsne_data_hc <- tsne_data_hc %>% 
  mutate(label = ifelse(name %in% labels$name, as.character(name), ""))

ggplot(aes(x = X, y = Y), data = tsne_data_hc) +
  geom_point(aes(color = cluster)) + 
  geom_text(aes(X,Y,label=label))


```

## Density Clustering with Optics


```{r}
#18 dimensions, so set k = 19
kNNdistplot(gower_dist, k=19)
abline(h=0.16, col='red', lty=2)

res_col <- optics(gower_dist, eps=10, minPts = 7)

plot(res_col)
```

```{r}
#5 clusters, 21 noise points
res_col_d <- extractDBSCAN(res_col, eps_cl=0.0915)
plot(res_col_d)
```

```{r}
tsne_data_den_d<- tsne_obj$Y %>%
  data.frame() %>% 
  setNames(c("X", "Y")) %>%
  mutate(cluster = factor(res_col_d$cluster),
         name = data_clean$Country)

set.seed(5)
labels <- tsne_data_den_d %>% 
    filter(cluster != "0") %>% 
    group_by(cluster) %>%
    sample_n(.,1) 

tsne_data_den_d <- tsne_data_den_d %>% 
  mutate(label = ifelse(name %in% labels$name, as.character(name), ""))

ggplot(aes(x = X, y = Y), data = tsne_data_den_d) +
  geom_point(aes(color = cluster)) + 
  geom_text(aes(X,Y,label=label)) +
  scale_color_manual(values=c("#999999",
                              "#F8766D",
                              "#00BCD8",
                              "#E76BF3",
                              "#6BB100",
                              "#619CFF"))
```


#Predictive Tasks

##Decision Trees