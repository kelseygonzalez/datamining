---
title: 'Final Project'
author: "Kelsey Gonzalez and Laura Werthmann"
date: "Due Dec 11, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r global_options, echo=FALSE}
knitr::opts_chunk$set(message=FALSE, warning=FALSE,fig.width=5)
```


Load packages
```{r}
library(tidyverse)    # data manipulation and visualization
library(kernlab)      # SVM methodology
library(e1071)        # SVM methodology
library(ISLR)         # contains example data set "Khan"
library(RColorBrewer) # customized coloring of plots
library(performanceEstimation) # for performance estimation of svm
library(RCurl) # for performance estimation of svm

```

#Data Preprocessing

Review of World Health Organization's Life Expectancy Data taken from [Kaggle](https://www.kaggle.com/kumarajarshi/life-expectancy-who).

```{r}
rm(list=ls())
load("LifeExpectancyData.Rdata")
data$Status = as.factor(data$Status)
data = subset(data,select = -c(`Hepatitis B`))
```

Then we aquire data to include continent values and make our cuboid navigation easier. This will allow us to "roll up" to other country-key table elements.
```{r}
# from https://github.com/lukes/ISO-3166-Countries-with-Regional-Codes
ISO3166 <- read.csv(text = (getURL("https://raw.githubusercontent.com/lukes/ISO-3166-Countries-with-Regional-Codes/master/all/all.csv")))
ISO3166$name <- as.character(ISO3166$name)
# They use Eswatini instead of Swaziland, so let's update that & other naming mismatches
ISO3166$name[ISO3166$name == "Eswatini"] <- "Swaziland"
ISO3166$name[ISO3166$name == "Moldova, Republic of"] <- "Republic of Moldova"
ISO3166$name[ISO3166$name == "Korea, Republic of"] <- "Republic of Korea"
ISO3166$name[ISO3166$name == "Korea (Democratic People's Republic of)"] <- "Democratic People's Republic of Korea"
ISO3166$name[ISO3166$name == "Congo, Democratic Republic of the"] <- "Democratic Republic of the Congo"
ISO3166$name[ISO3166$name == "North Macedonia"] <- "The former Yugoslav republic of Macedonia"
ISO3166$name[ISO3166$name == "Tanzania, United Republic of"] <- "United Republic of Tanzania"
```

We created a country data frame to make the data join more easily, and then joined them by country("country", "name"), while adding the continent ("region")
```{r}
countries <- as.data.frame(unique(data$Country))
colnames(countries) <- "Country" 
countries$Country <- as.character(countries$Country)

dfcountry <- left_join(x = countries, 
                   y = ISO3166, 
                   by = c("Country" = "name"))


data <- left_join(x = data,
                   y = dfcountry[,c("Country","region")], 
                   by = c("Country" = "Country"))
```

```{r}
data$Life <- data$`Life expectancy`
data$Status = as.factor(data$Status)
data$Country = as.factor(data$Country)

data <- data %>% select(-c(Polio, "percentage expenditure", Measles, `HIV/AIDS`)) 

data2013 <- data %>% filter(Year=="2013") %>% drop_na()

```


#Describe Data set

https://designing-ggplots.netlify.com/#49
```{r}
load("LifeExpectancyData_3.Rdata")

library(ggrepel)

ten_countries <- 
  data %>% 
  filter(Year == 2013) %>% 
  select(Country) %>% 
  arrange() %>% 
  head()

p1 <- data %>%
  filter(Year == 2013) %>%
  drop_na() %>% 
  mutate(label = ifelse(Country %in% ten_countries,Country,"")) %>%
  ggplot(aes(log(GDP), `Life expectancy`)) +
  geom_point(size = 3.5, 
             alpha = .9,
             shape = 21, 
             col = "white", 
             fill = "#0162B2")

scatter_plot <- p1 + 
  geom_text_repel(aes(label = label),
                  size = 4.5,
                  point.padding = .2,
                  box.padding = .3,
                  force = 1,
                  min.segment.length = 0) +
  theme_minimal(14) +
  theme(legend.position = "none",
        panel.grid.minor = element_blank()) +
  labs(x = "log(GDP)",
       y = "life expectancy")
scatter_plot


```



```{r, echo=FALSE}
#http://rpubs.com/nicholas_dirienzo/523778
require(reshape2)

data_melted <- data %>%
  filter(Year == 2013) %>% 
  select(-Country, -Status, -region) # remove the character columns we don't need

data_melted <- melt(as.data.frame(data_melted))

ggplot(data_melted,
       aes(x = value)) +
  geom_histogram() +
  facet_wrap(~variable)

```



#Descriptive Analyses
## ? Clustering 


First things first, do our data even have a natural clustering tendency?
the smaller the result, the higher clustering tendency
```{r}
#Hopkins, for numerical data only 
# Compute Hopkins statistic for iris dataset:n must be no larger than num of samples
# seed set internally in the function, always give the same result.

data_no_cat <- data2013 %>% select(-Country, -Status, -region)

res <- get_clust_tendency(data_no_cat, n=138, graph = TRUE)
res$hopkins_stat
res$plot

set.seed(1)
res <- hopkins(data_no_cat, n = 138)
res$H #very small, < 0.5, good clustering tendency
```





```{r}
gower_dist <- daisy(data2013[, -1],
                    metric = "gower",
                    type = list(logratio = "GDP", 
                                logratio = "Population"))

# Check attributes to ensure the correct methods are being used (I = interval, N = nominal)
# Note that despite logratio being called, the type remains coded as "I"
summary(gower_dist)

# cleaning it up
gower_mat <- as.matrix(gower_dist)
rownames(gower_mat) <- colnames(gower_mat) <- data2013$Country


```

Calculate Silhouette width for 2 to 10 clusters using PAM

```{r}
sil <- c(NA)
for(i in 2:10){
  pam_fit <- pam(gower_mat, diss=TRUE, k=i)
  sil[i] <-pam_fit$silinfo$avg.width
}

plot(1:10, sil,
xlab = "Number of clusters",
ylab = "Silhouette Width",
lines(1:10, sil))
```

```{r}
pam_fit <- pam(gower_dist, diss = TRUE, k = 4)
# add cluster labels to the data. We will use result1 later
data_clean <- data.frame(data2013, pam_fit$cluster)
# show clustering results by country
result1 <- data_clean %>% select(Country,pam_fit.cluster)
clusplot(pam_fit)

```

group_by cluster and then compute the summary data (means, median, etc) for each cluster
```{r}
data_results <- data_clean %>%
  mutate(cluster = pam_fit.cluster) %>% #add the cluster column
  select(-pam_fit.cluster) %>% 
  group_by(cluster) %>% #group countries by its cluster 
  do(the_summary = summary(.)) #do: summarize by group/cluster,add the_summary column

data_results$the_summary
```
The results suggest

_Cluster 1_:Developing countries in Asia with a LE of 68 with a mean GDP of 1,283.  
_Cluster 2_: Developing countries in Europe with a mean LE of 76 with a mean GDP of 9,872.  
_Cluster 3_: Developing countries in Africa with a mean LE of 61 with a mean GDP of 1,962.   
_Cluster 4_: Developing countries in the Americas with a mean LE of 74 with a mean GDP of 7,347.  
_Cluster 5_: Developing countries in Asia with a mean LE of 72 with a mean GDP of 5,052.  
_Cluster 6_: Developed countries in Europe and Asia with a mean LE of 80 with a mean GDP of 20,710.  

One way to visualize many variables in a lower dimensional space is with t-distributed stochastic neighborhood embedding, or t-SNE. 
```{r}
tsne_obj <- Rtsne(gower_dist, is_distance = TRUE)

tsne_data <- tsne_obj$Y %>%
  data.frame() %>% 
  setNames(c("X", "Y")) %>%
  mutate(cluster = factor(pam_fit$clustering),
         name = data_clean$Country)

ggplot(aes(x = X, y = Y), data = tsne_data) +
  geom_point(aes(color = cluster)) + 
  geom_text(data=subset(tsne_data[pam_fit$medoids, ]), # add names of centroids in 
            aes(X,Y,label=name))
```

#Predictive Tasks
##Decision Trees